## 预测身高
* 男孩成人后身高=（父亲身高+母亲身高）/21.08
　女孩成人后身高=(父亲身高0.923+母亲身高）/2
  男性用整数1表示，女性用整数0表示。
　预测的身高保留三位小数
样例输入
1 1.91 1.70
样例输出
1.949
```python
a,m,n=list(map(float,input().split()))  #有时候是float

if a==1:
    print(round((m+n)/2*1.08,3))   #round(n,3)的用法,3代表小数点后三位小数
elif a==0:
    print(round((m*0.923+n)/2,3))
```
## 最长滑雪道
* 滑雪区域：
* ![image](https://user-images.githubusercontent.com/46865901/114292145-0d72f200-9abf-11eb-8746-b2e82ca51fcd.png)
* 一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。你的任务就是找到最长的一条滑坡，并且将滑坡的长度输出。 滑坡的长度定义为经过点的个数，例如滑坡24-17-16-1的长度是4。
* 输入：
* 5 5
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
* 输出：
25
```python
#最长滑雪道                  这类题目不是深度搜索（递归）就是广度搜索可以对比一下！
def test(x,y):
    dp[x][y]=1
    for i in range(4):
        tx=x+d[i][0]
        ty=y+d[i][1]
        if 0<=tx<m and 0<=ty<n:
            if num[tx][ty]>=num[x][y]:
                continue
            dp[x][y]=max(dp[x][y],test(tx,ty)+1)  #这里是test(tx,ty)是递归/深度搜索的思想（如果用dp[tx][ty],它有可能还没有更新，为0）
    return dp[x][y]                         #做返回！！
        
    
m,n=list(map(int,input().split()))
num=[list(map(int ,input().split()))for _ in range(m)]  #!!!

dp=[[0]*n for _ in range(m)]   #记录从每个点的最大长度！！！！经常使用
d=[[-1,0],[1,0],[0,-1],[0,1]]

ans=float('-inf')
for i in range(m):
    for j in range(n):
        ans=max(ans,test(i,j))

print(ans)
```
## k好数
* 如果一个自然数N的K进制表示中任意的相邻的两位都不是相邻的数字，那么我们就说这个数是K好数。求L位K进制数中K好数的数目。例如K = 4，L = 2的时候，所有K好数为11、13、20、22、30、31、33 共7个。
* 样例输入
4 2
* 样例输出
7
```python
k,l=list(map(int,input().split()))

def test(dep):
    for i in range(0,len(dep)-1):
        if abs(dep[i]-dep[i+1])==1:
            return False
    return True

dep=[]
ans=0
t=0
for i in range(l):    #注意对于k进制最大的是k-1
    t+=(k-1)*k**i

for i in range(k,t+1):  #这里是t+1
    while(i!=0):
        dep.append(i%k)
        i=i//k
    if test(dep)==True:
        ans+=1
    dep=[]
print(ans%1000000007)
```
## 成绩排名
* 按照成绩给学生的姓名排名。
* 样例输入
3
aaa 47
bbb 90
ccc 70
* 样例输出
bbb
ccc
```python
#成绩排名
n=int(input())
num=[]
grade=[]

for i in range(n):
    num.append(input().split())
    grade.append([int(num[i][1]),i])

grades=sorted(grade,key=lambda x:x[0],reverse=True)  #sort和sorted的用法，较为复杂的还是用sorted
print(grades)
for i in range(n):
    print(num[grades[i][1]][0])
```
## 递归倒置字符数组
* 按照成绩给学生的姓名排名。
* 样例输入
* 5 abcde
* 样例输出
* ebcda
* edcba
* edcba
```python
n,string=input().split()
n=int(n)
string=list(string)    #list之后再str还是['a', 'b', 'c', 'd', 'e']

if n==1:
    print(''.join(string))
else:
    for k in range(0,n//2+1):
        string[k],string[n-1-k]=string[n-1-k],string[k]
        print(''.join(string))
    
#print('\n'+''.join(s))  注意'\n'表示输出回车
```
## 幸运观众
* 看清楚题
* 每位顾客可至抽奖台抽取一个幸运号码，该商场在抽奖活动推出的第i天将从所有顾客中（包括不在本日购物满30元者）挑出幸运号第i小的顾客作为当日的幸运顾客。
* 样例输入
* 6
* 3
* 4
* -1
* -1
* 3
* -1
* 样例输出
* 3
* 4
* 4
```python
#幸运观众
n=int(input())
num=[]
ans=[]
p=0
for i in range(n):
    k=int(input())
    if k!=-1:
        num.append(k)
    else:
        num.sort()
        ans.append(num[p])
        p+=1

for i in range(len(ans)):
    print(ans[i])
```
## 最长公共子序列
* 给定两个字符串，寻找这两个字串之间的最长公共子序列。
* 样例输入
* abcdgh
* aedfhb
* 样例输出
3
（a，d，h）
* 思想：
* ![Uploading image.png…]()
* ![Uploading image.png…]()
```python
#最长公共子序列
a=list(input())
b=list(input())
m=len(a)
n=len(b)
num=[[0 for _ in range(n+1)]for _ in range(m+1)]

for i in range(1,m+1):
    for j in range(1,n+1):
        if i==0 and j==0:
            num[i][j]=0
        elif i>0 and j>0 and a[i-1]==b[j-1]:
            num[i][j]=num[i-1][j-1]+1
        elif i>0 and j>0 and a[i-1]!=b[j-1]:
            num[i][j]=max(num[i-1][j],num[i][j-1])

print(num[m][n])
```
## 龟兔赛跑
* 兔子的速度v1（表示每秒兔子能跑v1米），乌龟的速度v2，以及兔子对应的t，s值，以及赛道的长度，一旦任一秒结束后兔子发现自己领先t米或以上，它们就会停下来休息s秒。
* 样例输入
* 10 5 5 2 20
* 样例输出
* D
* 4
* 其中！！！！第二行输出一个正整数！！！整秒数
```python
#龟兔赛跑
s=list(map(int,input().split()))

l1=0
l2=0
t=0
while True:               #while True不用写变量，只要不break就循环
    if l1==s[-1] and l2==s[-1]:  #都赢
        print('D',t)
        break
    elif l1==s[-1]:      #兔子
        print('R',t)
        break
    elif l2==s[-1]:       #乌龟
        print('T',t)
        break
    if (l1-l2)>=s[2]:
        for i in range(s[3]):
            if l2<s[-1]:
                t+=1
                l2+=s[1]
            else:
                print('T',t)
                break                            
                
    t+=1
    l1+=s[0]
    l2+=s[1]
```
## n皇后
* 要在n*n的国际象棋棋盘中放n个皇后，使任意两个皇后都不能互相吃掉。规则：皇后能吃掉同一行、同一列、同一对角线的任意棋子。求所有的解。n=8是就是著名的八皇后问题了。

```python
# 递归回溯思想解决n皇后问题
def queen(vis, k):
    if k == n:             # 所有的皇后都正确放置完毕，输出每个皇后所在的位置
        print(vis)
        return 0
    for col in range(n):
        vis[k]=col
        flag=True
        for i in range(k): # 检测本次所放皇后的位置是否在同行同列或同一对角线上
            if vis[i] == col or abs(col - vis[i]) == k - i: # 有问题，该位置不能放，向上回溯
                flag = False
                break
        if flag==True:     #OK，继续放下一个皇后
            queen(vis, k+1)


n = int(input())            # n为8，就是著名的八皇后问题啦

queen([0] * n,0)
```
## 矩阵面积交
* 平面上有两个矩形，它们的边平行于直角坐标系的X轴或Y轴。对于每个矩形，我们给出它的一对相对顶点的坐标，请你编程算出两个矩形的交的面积。
* 输入
* 1 1 3 3
* 2 2 4 4
* 输出
* 1.00
```python
#这类题目记得找他们之间的关系
m=list(map(int,input().split()))
n=list(map(int,input().split()))

#两个矩阵的对角点中（两个小横坐标中的大的）小于（两个大横坐标中的小的）。
#两个矩阵的对角点中（两个小纵坐标中的大的）小于（两个大纵坐标中的小的）。

x1=max(m[0],n[0])
x2=min(m[2],n[2])
y1=max(m[1],n[1])
y2=min(m[3],n[3])

if x1<x2 and y1<y2:
    print(round((x2-x1)*(y2-y1),2))
```

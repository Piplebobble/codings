## 不同子串
* 一个字符串的非空子串是指字符串中长度至少为 1 的连续的一段字符组成 的串。例如，字符串aaab 有非空子串a, b, aa, ab, aaa, aab, aaab，一共 7 个。 注意在计算时，只算本质不同的串的个数。
   请问，字符串0100110001010001 有多少个不同的非空子串？
```python
var='0100110001010001'     #字符串
test=[]                    #列表
num=1                      #串本省就是
step=1
while step<len(var):
    test.append(var[0:step])         #每个长度串的第一个
    for i in range(len(var)-step):   #以step为长度每次向后推进，每一轮的长度都是一样的
        if var[i+1:i+step+1] in test:
            continue
        else:
            test.append(var[i+1:i+step+1])
    step+=1
    num+=len(test)
    test=[]
print(num)
```
## 年号对应字符串
* 小明用字母A 对应数字1，B 对应2，以此类推，用Z 对应26。对于27，以上的数字，小明用两位或更长位的字符串来对应，例如AA 对应27，AB 对应28，AZ 对应52，LQ 对应329。
请问2019 对应的字符串是什么？
```python
var='ABCDEFGHIJKLMNOPQRSTUVWXYZ'  #字符串
result=[]
n=int(input())
s=[]
while(n!=0):
    s.append(n%26)
    n=int(n/26)                   #注意一定要int(n/26)

for j in range(0,len(s)):
    t=int(s[j])
    result.append(var[t-1])
#result.reverse()                  数组逆转result.reversed（）
#                                   字符串逆转string[::-1].  ''.join(reverse(''))
string=''.join(reversed(result))  #数组转成字符串，string=''.join（result）
print(string)
```
## 数列求值
* 给定数列 1, 1, 1, 3, 5, 9, 17, …，从第 4 项开始，每项都是前 3 项的和。求第 20190324 项的最后 4 位数字。
```python
s=[0 for i in range(20190325)]  #定义指定长度的数组，可以直接赋值s[i]=值，未定义指定长度的数组s.append()
s[0]=s[1]=s[2]=1
for i in range(3,20190325):
    s[i]=(s[i-1]+s[i-2]+s[i-3])%10000  #只保留后4位直接%10000

print(s[20190323])
```
## 数的分解
* 把 2019 分解成 3 个各不相同的正整数之和，并且要求每个正整数都不包含数字 2 和 4，一共有多少种不同的分解方法？
  注意交换 3 个整数的顺序被视为同一种方法，例如 1000+1001+18 和 1001+1000+18 被视为同一种。
```python
n=int(input())
num=0
def test(n):
    n=str(n)
    if ('2' in n) or ('4' in n):    #不可以写成‘2’ or ‘4’ in n
        return False
    return True
    
for i in range(1,2019):
    if test(i):
        for j in range(i+1,2019):
            if test(j):
                if test(2019-i-j) and (2019-i-j)>j:#由于交换顺序属于同一种方法且3个数不同，所以可以用（递增的）
                    num+=1
print(num)

```
## 完全二叉树的权值
* 求完全二叉树中哪一层元素相加最大？
  
```python
import math
n=int(input())
num=list(map(int,input().split()))
result=[0]*(int(math.log(n,2))+1)  #注意长度为n的数组对应树的高度,log的写法

result[0]=num[0]
number=result[0]
t=1

for i in range(1,len(result)):
    p=2**i-1
    q=2**(i+1)-1
    result[i]=sum(num[p:q])       #注意数组下标跟它本身长度关系
    print(result[i])
    if result[i]>number:
        number=result[i]
        t=i+1
print(t)

```
## 等差数列
* 求等差数列长度最短是多少？
  
```python
n=int(input())
num=list(map(int,input().split()))

ch=float('inf')
num=sorted(num)      #都可以num=sorted(num)和num.sort

for i in range(1,len(num)):
    ch=min(ch,num[i]-num[i-1])

result=int((num[len(num)-1]-num[0])/ch)+1
print(result)
```
## 换钞票
* x星球的钞票的面额只有：100元，5元，2元，1元，共4种。
小明去x星旅游，他手里只有2张100元的x星币，太不方便，恰好路过x星银行就去换零钱。
小明有点强迫症，他坚持要求200元换出的零钞中2元的张数刚好是1元的张数的10倍，
剩下的当然都是5元面额的。银行的工作人员有点为难，你能帮助算出：在满足小明要求的前提下，最少要换给他多少张钞票吗？
（5元，2元，1元面额的必须都有，不能是0）
```python
n=int(input())
for i in range(1,10):   #注意这里的关系，2元的张数是1元的10倍，两元最多有100张，估1元最多有10张
    a=i
    b=a*10
    c=n-b*2-a
    if c%5==0 and c!=0:
        c=int(c/5)
        count=int(a+b+c)
        print(a,b,c,count)
```
## 分数相加+约分
* 1/1 + 1/2 + 1/4 + 1/8 + 1/16 + …
每项是前一项的一半，如果一共有20项,求这个和是多少，结果用分数表示出来。
类似：
3/2
```python
def gcd(p,q):
    if q==0:
        return p
    return gcd(q,p%q)
n=int(input())
fz=fm=1
x=y=1

for i in range(1,n):
    fm=fm*2
    fz=1
    x=x*2+fz
    y=y*2
    i+=1

t=gcd(x,y)
print(int(x/t),'/',int(y/t))
```
## 购物单
* 
****     180.90       88折
****      10.25       65折
****      56.14        9折
****     104.65        9折
****     100.30       88折
****     297.15       半价
****      26.75       65折
****     130.62       半价
需要多少张100？
首先在把数据复制到记事本中，其次用Ctrl+H键替换，把****用空格替换，把7折、8折、9折替换为70、80、90，半价替换为50，其余折用空格替换，预处理后数据为：
180.90  88  
 10.25  65  
 56.14   90  
104.65   90  
100.30  88  
297.15  50  
```python
def result(s):
    return (float(s[0]) * (float(s[1])/ 100) )

file = open('D:/1just/data.txt', 'r')  #r和r+,w和w+
ans = 0

for line in file.readlines():      #file.readlines()
    s = line.split()                #split()函数
    ans += result(s)

file.close()
print(ans)
```
## 等差素数列
* 7,37,67,97,127,157 这样完全由素数组成的等差数列，叫等差素数数列。
2004年，格林与华人陶哲轩合作证明了：存在任意长度的素数等差数列。这是数论领域一项惊人的成果！
有这一理论为基础，请你借助手中的计算机，满怀信心地搜索：长度为10的等差素数列，其公差最小值是多少？
```python
import math
p=float('inf')
t=0

def test(n):
    if n==1: return False
    for i in range(2,int(math.sqrt(n))+1):
        if n%i==0:
            return False
    return True
N = 10000    #一般可以设置的最大值是多少？############??
a=[0]*N
flag=[0]*N

for i in range(1,N):
    a[i]=i
    if test(i)==True:
        flag[i]=1    #flag为1代表为素数


for i in range(1,N):
    if flag[i]==1:
        ch=1
        while (i+9*ch)<N:
            k=1                #连续的长度
            while flag[i+k*ch]==1 and (i+k*ch)<N:
               k+=1
               if k==9:
                   p=min(p,ch)   #公差最小值
                   break
            ch+=1

print(p)
```
## 方格分割
* 6x6的方格，沿着格子的边线剪开成两部分。要求这两部分的形状完全相同。
求一共有多少种不同的分割方法。注意：旋转对称的属于同一种分割法。
类似：
![image](https://user-images.githubusercontent.com/46865901/112639687-834e4b00-8e7b-11eb-9276-15466f4fe4c8.png)
* 解题方法分析：
1.递归+回溯 思路
2.6*6的方格有7*7个点。以方格的中心点（3，3）
3.增加辅助数组，用来记录走过的点，走过的点与点之间的线为切割线
4.初始从中心点出发，两个指针分别向两个相对的方向移动，
  即：（x,y）上下左右移，(6-x,6-y)下上右左移动,利用数组vir辅助移动
5.走过的点在辅助数组t中记为1，递归后进行回溯
6.如果点的位置到达边界，即 x,y=0或x,y=6 即完成一种情况 count++;
7. 因为旋转 对称后视为一种情况，所以结果 count/4；

```python
def dfs(x,y):
    global ans        # 定义ans为全局变量
    if x==0 or y==0 or x==n or y==n:    #只要碰到边界分割就结束
        ans+=1
        return
    for i in range(4):                   #没到一个点都可以向上下左右四个方向走
        tx=x+d[i][0]
        ty=y+d[i][1]
        if s[tx][ty]==0:
            s[tx][ty]=1                  #走过变成1
            s[n-tx][n-ty]=1
            dfs(tx,ty)                   #从该点继续迭代
            s[tx][ty]=0                  #恢复变成0
            s[n-tx][n-ty]=0

    return ans//4                      #重复的//4

n=6
s=[[0]*(n+1)for i in range(n+1)]          #定义整个点矩阵
s[3][3]=1
d=[(-1,0),(1,0),(0,-1),(0,1)]             #方向
ans=0
print(dfs(3,3))                            #由于是对称的所以从中点走，[x,y]和[n-x,n-y]是一样的
```

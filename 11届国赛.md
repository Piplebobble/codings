## 本质上升
* 在一个字符串中，如果取出若干个字符，将这些字符按照在字符串中的顺序排列后是单调递增的，则成为这个字符串中的一个单调递增子序列。
例如，在字符串 lanqiao 中，如果取出字符 n 和 q，则 nq 组成一个单调递增子序列。类似的单调递增子序列还有 lnq、 i、 ano 等等。
小蓝发现，有些子序列虽然位置不同，但是字符序列是一样的，例如取第二个字符和最后一个字符可以取到 ao，取最后两个字符也可以取到 ao。小蓝
认为他们并没有本质不同。对于一个字符串，小蓝想知道，本质不同的递增子序列有多少个？
例如，对于字符串 lanqiao，本质不同的递增子序列有 21 个。它们分别是 l、 a、 n、 q、 i、 o、 ln、 an、 lq、 aq、 nq、 ai、 lo、 ao、 no、 io、 lnq、anq、 lno、 ano、 aio。
请问对于以下字符串（共 200 个小写英文字母，分四行显示）：（如果你把以下文字复制到文本文件中，请务必检查复制的内容是否与文档中的一致。在试题目录下有一个文件 inc.txt，内容与下面的文本相同）
tocyjkdzcieoiodfpbgcncsrjbhmugdnojjddhllnofawllbhf
iadgdcdjstemphmnjihecoapdjjrprrqnhgccevdarufmliqij
gihhfgdcmxvicfauachlifhafpdccfseflcdgjncadfclvfmad
vrnaaahahndsikzssoywakgnfjjaihtniptwoulxbaeqkqhfwl
本质不同的递增子序列有多少个？

```python
#本质上升序列
#动态规划，
file=open('D:/1just/study/coding/data.txt','r')
n=''
for line in file.readlines():
    n+=line.strip()
n=list(n)  #不list直接字符串也可以

l=len(n)
dp=[1]*l                   #dp[i]表示以num[i]为结尾的子序列个数
res=0
for i in range(l):
    for j in range(i):
        if n[i]>n[j]:       #如果i大于j,就dp[i]=dp[i]+dp[j]
            dp[i]+=dp[j]
        if n[i]==n[j]:      #如果i==j，就dp[i]=dp[i]-dp[j]，因为计算了两次
            dp[i]-=dp[j]
for i in dp:
    res+=i
print(res)
```

## 重复字符串
* 如果一个字符串 S 恰好可以由某个字符串重复 K 次得到，我们就称 S 是 K 次重复字串。例如 “abcabcabc” 可以看作是 “abc” 重复 3 次得到，所以“abcabcabc” 是 3 次重复字符串。
同理 “aaaaaa” 既是 2 次重复字符串、又是 3 次重复字符串和 6 次重复字符串。
现在给定一个字符串 S，请你计算最少要修改其中几个字符，可以使 S 变为一个 K 次字符串？
```
n=int(input())
s=list(map(str,input().strip()))
if len(s)%n!=0:
    print(1)
else:
    number=0
    t = len(s) // n
    nums=[[0]*t for i in range(n)]  
    for i in range(n):
        for j in range(t):
            nums[i][j]=s[i*t+j]

    for i in range(t):
        count=0
        s=[]
        for j in range(n):
            s.append(nums[j][i])
        for j in range(n):
            a=s.count(nums[j][i])
            count=max(count,a)
        number+=(abs(n-count))
    print(number)

```
## 阶乘约数
* 注释
* ![image](https://user-images.githubusercontent.com/46865901/111158116-a141c300-85d2-11eb-99f2-027c1d23de71.png)

```
n=int(input())
s=list(map(str,input().strip()))
if len(s)%n!=0:
    print(1)
else:
    number=0
    t = len(s) // n
    nums=[[0]*t for i in range(n)]  
    for i in range(n):
        for j in range(t):
            nums[i][j]=s[i*t+j]

    for i in range(t):
        count=0
        s=[]
        for j in range(n):
            s.append(nums[j][i])
        for j in range(n):
            a=s.count(nums[j][i])
            count=max(count,a)
        number+=(abs(n-count))
    print(number)

```
## 最短路径
* 不对

```
import math
m,n=map(int,input().split())
s = [list(map(int,input().split())) for _ in range(m)]
# s=[[]*2 for i in range(m)]
nums=[[0]*2 for i in range(m)]

result = float('inf')
for i in range(m):
    nums[i][0]=0
    nums[i][1]=1
    for j in range(m):
        if j!=m:
            nums[j][0]=int(math.sqrt((s[i][0]-s[j][0])**2+(s[i][1]-s[j][1])**2))
            nums[j][1]=0
    #每次都新建数组
    count=0
    for i in range(m):
        minx=float('inf')
        t=0
        for j in range(m):                   #找到本次最小的
            if nums[j][1]!=1 and nums[j][0]<minx:
                    minx=nums[j][0]
                    t=j
        nums[t][1]=1
        count+=minx
        for i in range(m):
            if nums[i][1]!=1:
                nums[i][0]=min(nums[i][0],nums[t][0]+int(math.sqrt((s[i][0]-s[t][0])**2+(s[i][1]-s[t][1])**2)))

    result=min(result,count)
print(result)

```
